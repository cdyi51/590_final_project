# 590_final_project

The design of this Dining Philosophers problem is centered around ensuring safety and avoiding common concurrency pitfalls such as deadlocks and race conditions. Rust's ownership model and synchronization primitives, like `Mutex`, `Arc`, and atomic types, were crucial in crafting this implementation. The choice of these tools aligns with Rust's emphasis on memory safety and concurrency correctness without sacrificing performance.

Forks are represented as individual `Mutex<Fork>` objects, stored in a vector wrapped by an `Arc`. The `Mutex` provides mutual exclusion, ensuring that only one philosopher can hold a fork at a time. By wrapping the vector in `Arc`, we allow multiple philosopher threads to access and lock the forks safely. The explicit locking and unlocking of forks within the philosopher threads make it clear when resources are being used, aiding both performance and debugging.

Philosophers themselves are implemented as structs containing their names, fork indices, and atomic counters for eating and thinking. These counters use `AtomicUsize` for efficient and thread-safe updates, reflecting the philosophers' activities in real-time. The `dine` method orchestrates the core behavior: philosophers repeatedly pick up their forks, eat, drop the forks, and think. Using scoped locking through RAII ensures that locks on the forks are released automatically when no longer needed, preventing deadlocks caused by forgotten or delayed releases.

The simulation includes a termination mechanism facilitated by an `AtomicBool` stop signal. This signal is shared among all threads and is checked within the philosophers' loops to determine when to cease operations. The program listens for user input to trigger this signal, leveraging Rust's `mpsc` channel for efficient communication between the main thread and the philosopher threads. This approach ensures that the simulation runs indefinitely until the user intervenes, and it gracefully terminates, reporting the philosophers' activity counts. This integration of Rust's concurrency features ensures a robust, safe, and efficient implementation of the Dining Philosophers problem.

